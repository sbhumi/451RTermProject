CREATE TABLE STUDENT
(STUDENTID INT NOT NULL,
FIRST_NAME VARCHAR(20) NOT NULL,
LAST_NAME VARCHAR(20) NOT NULL,
YEAR_GRAD INT NOT NULL,
EMAIL VARCHAR(50) NOT NULL,
PHONE BIGINT NOT NULL,
GTA_CERT_LOCATION VARCHAR(50),
GTA_TERM DATE,
INTERNATL BIT,
GRADE_LEVEL VARCHAR(10) NOT NULL,
GPA FLOAT,
HOURS_COMPLETED INT,
SEMESTERS_COMPLETED INT,
CURRENT_MAJOR_FEILD VARCHAR(50),
UNDERGRAD_DEGREE_TYPE VARCHAR(50),

CONSTRAINT PKSTUDENT PRIMARY KEY(STUDENTID),
CONSTRAINT GRADEFORMAT CHECK (GRADE_LEVEL = 'M' OR GRADE_LEVEL = 'U'),
CONSTRAINT GRADERANGE CHECK(GPA <= 4.0 AND GPA >= 0.0)
);
GO

CREATE TABLE CLASSES
(CLASSID INT NOT NULL,
DEPARTMENT VARCHAR(50) NOT NULL,
CLASS_DESCRIPTION VARCHAR(250),
CLASS_NAME VARCHAR(20) NOT NULL,
CONSTRAINT PKCLASSES PRIMARY KEY(CLASSID)
);
GO

CREATE TABLE CLASS_TERMS (
CLASSID INT NOT NULL,
TERM DATE NOT NULL,
SECTION INT,
CONSTRAINT PKCLASS_TERMS PRIMARY KEY(CLASSID, TERM),
CONSTRAINT CLASS_TERMSFKCLASS FOREIGN KEY(CLASSID) REFERENCES CLASSES(CLASSID)
ON DELETE CASCADE
);
GO


CREATE TABLE JOB
(CLASSID INT NOT NULL,
JOB_ID INT NOT NULL,
JOB_TITLE VARCHAR(50) NOT NULL,
POSITIONS_AVAILABLE INT NOT NULL,
JOB_DESCRIPTION VARCHAR(250) NOT NULL,
CONSTRAINT PKJOB PRIMARY KEY(JOB_ID),
CONSTRAINT JOBFKCLASSES FOREIGN KEY(CLASSID) REFERENCES CLASSES(CLASSID)
ON DELETE CASCADE,
CONSTRAINT NUMJOBS CHECK(POSITIONS_AVAILABLE >= 0)
);
GO


CREATE TABLE APPLICATIONS
(STUDENTID INT NOT NULL,
JOBID INT NOT NULL,
JOBSTATUS VARCHAR(20) NOT NULL,
CONSTRAINT PKAPPLICATIONS PRIMARY KEY(STUDENTID, JOBID),
CONSTRAINT APPLICATIONSFKSTUDENT FOREIGN KEY(STUDENTID) REFERENCES STUDENT(STUDENTID)
ON DELETE CASCADE,
CONSTRAINT APPLICATIONSFKJOB FOREIGN KEY(JOBID) REFERENCES JOB(JOB_ID)
ON DELETE CASCADE
);
GO

CREATE TABLE CLASSES_TAKEN
(STUDENTID INT NOT NULL,
CLASSID INT NOT NULL,
GRADE FLOAT NOT NULL,
AT_UMKC BIT NOT NULL,
LOCATION_TAKEN VARCHAR(50),
TERM DATE NOT NULL,
CONSTRAINT PKCLASSES_TAKEN PRIMARY KEY(STUDENTID, CLASSID),
CONSTRAINT FKCLASSES_TAKENFKSTUDENT FOREIGN KEY(STUDENTID) REFERENCES STUDENT(STUDENTID)
ON DELETE CASCADE,
CONSTRAINT CLASSES_TAKENFKCLASSES FOREIGN KEY(CLASSID) REFERENCES CLASSES(CLASSID)
ON DELETE CASCADE,
CONSTRAINT GRADERANGETAKEN CHECK(GRADE <= 4.0 AND GRADE >= 0.0)
);
GO

CREATE TABLE JOB_REQUIREMENTS
(JOBID INT NOT NULL,
CLASSID INT NOT NULL,
GRADE FLOAT NOT NULL,
CONSTRAINT PKJOB_REQUIREMENTS PRIMARY KEY(JOBID, CLASSID),
CONSTRAINT JOB_REQUIREMENTSFKJOBID FOREIGN KEY(JOBID) REFERENCES JOB(JOB_ID)
ON DELETE CASCADE,
CONSTRAINT JOB_REQUIREMENTSFKCLASSID FOREIGN KEY(CLASSID) REFERENCES CLASSES(CLASSID),
CONSTRAINT GRADERANGEREQUIREMENTS CHECK(GRADE <= 4.0 AND GRADE >= 0.0)
);
GO

/*
filterJobRequirements:
returns classes and grade in classes needed to apply to a job
Dependencies: 
Parameters:
JOBID INT: ID of the job being applied for
*/

CREATE PROCEDURE filterJobRequirements
	@JOBID INT
AS
	SET NOCOUNT ON;
	SELECT CLASSID, GRADE
	FROM JOB_REQUIREMENTS
	WHERE JOBID = @JOBID;
GO



/*
filterJob
returns jobtitle and positions available for a given class
Dependencies: 
Parameters:
CLASSID INT: ID of class being searched
*/

CREATE PROCEDURE filterJob
	@CLASSID int
AS
	SET NOCOUNT ON;
	SELECT JOB_TITLE, POSITIONS_AVAILABLE
	FROM JOB
	WHERE CLASSID = @CLASSID;
GO

/*

filterAppliationsbyJob
returns all students who have applied to a job
Dependencies
Parameters:
JOBID: (INT) ID of job being searched
*/

CREATE PROCEDURE filterApplicationsbyJob
	@JOBID INT
AS
	SET NOCOUNT ON;
	SELECT JOBID, STUDENTID
	FROM APPLICATIONS
	WHERE JOBID = @JOBID;
GO

/*
filterApplicationsbyClass
returns all applications associated with a class
Dependencies: 
Parameters:
CLASSID (INT): ID of class being searched
*/

CREATE PROCEDURE filterApplicationsbyClass
	@CLASSID INT
AS
	SET NOCOUNT ON;
	SELECT JOBID, STUDENTID
	FROM APPLICATIONS
	WHERE JOBID IN (
	SELECT JOB_ID
	FROM JOB
	WHERE CLASSID = @CLASSID);
GO

/*
filterApplicantsByJob:
returns student first and last name along with grade received in class 
Dependencies
Parameters:
JOBID: (int) ID of job being searched
*/

CREATE PROCEDURE filterApplicantsByJob
	@JOBID INT
AS
	SET NOCOUNT ON;
	SELECT  STUDENT.FIRST_NAME, STUDENT.LAST_NAME, CLASSES_TAKEN.GRADE
	FROM APPLICATIONS 
	INNER JOIN STUDENT
	ON APPLICATIONS.STUDENTID = STUDENT.STUDENTID
	INNER JOIN JOB 
	ON APPLICATIONS.JOBID = JOB.JOB_ID
	LEFT JOIN CLASSES_TAKEN
	ON APPLICATIONS.STUDENTID = CLASSES_TAKEN.STUDENTID AND CLASSES_TAKEN.CLASSID = JOB.CLASSID
	WHERE APPLICATIONS.JOBID = @JOBID;
GO



CREATE TRIGGER noApplyUnlessAllRequirementMet
ON APPLICATIONS AFTER INSERT
AS
IF (0 != (SELECT COUNT(CLASSES_TAKEN.GRADE) FROM 
JOB_REQUIREMENTS
INNER join inserted
ON inserted.JOBID = JOB_REQUIREMENTS.JOBID
LEFT JOIN CLASSES_TAKEN
ON JOB_REQUIREMENTS.CLASSID = CLASSES_TAKEN.CLASSID AND CLASSES_TAKEN.STUDENTID = inserted.STUDENTID
WHERE CLASSES_TAKEN.GRADE IS NULL))
BEGIN
	RAISERROR('Requirements not met',1,1);
	ROLLBACK
END
IF (0 != (SELECT COUNT(CLASSES_TAKEN.GRADE) FROM
JOB_REQUIREMENTS
join inserted
ON inserted.JOBID = JOB_REQUIREMENTS.JOBID
JOIN CLASSES_TAKEN
ON JOB_REQUIREMENTS.CLASSID = CLASSES_TAKEN.CLASSID AND CLASSES_TAKEN.STUDENTID = inserted.STUDENTID
WHERE CLASSES_TAKEN.GRADE <= JOB_REQUIREMENTS.GRADE))
BEGIN
	RAISERROR('Requirements not met',1,1);
	ROLLBACK
END
GO


/*

studentAdd
Inserts a new student into the database
Dependencies: 
Parameters:
SID (INT): ID of student being added
FIRSTN (VARCHA): FIRST NAME OF STUDENT
LASN (VARCHAR): LAST NAME OF STUDENT
YEARGRAD (INT): EXPECTED GRADUATION DAT
EMAIL (VARCHAR): EMAIL ADDRESS OF STUDENTS
PHONE (VARCHAR): PHONE NUMBER OF STUDENT
GTACERTLOC (VARCHAR): WHERE THE STUDENT RECEIVED THEIR GTA CERT
GTATERM DATE: DATE THE STUDENT RECEIVED THEIR GTA CERT
GPA (FLOAT): CUMULATIVE GPA
HOURSCOMPLETED (INT): NUMBER OF HOURS TAKEN AT UMKC
SEMESTERSCOMPLETED (INT): NUMBER OF SEMESTERS COMPLETED AT UMKC
CURRENTMAJOR (VARCHAR): CURRENT MAJOR
UNDERGRADDEGREETYPE (VARCHAR): WHAT STUDENT’S UNDERGRAD DEGREE TYPE
*/

CREATE PROCEDURE studentAdd
	@SID int,
	@FIRSTN VARCHAR(20),
	@LASTN VARCHAR(20),
	@YEARGRAD INT,
	@EMAIL VARCHAR(50),
	@PHONE BIGINT,
	@GTACERTLOC VARCHAR(50) = NULL,
	@GTATERM DATE = NULL,
	@INTERNATL BIT = 0,
	@GRADELEVEL VARCHAR(10),
	@GPA FLOAT,
	@HOURSCOMPLETED INT,
	@SEMESTERSCOMPLETED INT,
	@CURRENTMAJOR VARCHAR(50),
	@UNDERGRADDEGREETYPE VARCHAR(50)

AS
	SET NOCOUNT ON;
	INSERT INTO STUDENT
	VALUES (@SID, @FIRSTN, @LASTN, @YEARGRAD, 
	@EMAIL, @PHONE, @GTACERTLOC, @GTATERM, @INTERNATL, @GRADELEVEL,
	@GPA, @HOURSCOMPLETED, @SEMESTERSCOMPLETED, @CURRENTMAJOR, @UNDERGRADDEGREETYPE);
GO

alter table student
alter column phone bigint;
go

/*
jobAdd:
adds a new job
Dependencies: Class must exist before job
Parameters:
CLASSID (INT): ID OF CLASS JOB IS FOR
JOBID (INT): ID OF JOB BEING ADDED
JOBTITLE (VARCHAR): TITLE OF JOB
JOBSTATUS (INT): NUMBER OF POSITIONS AVAILABLE
JOBDESCRIPTION (VARCHAR): DESCRIPTION OF JOB
*/

CREATE PROCEDURE jobAdd
	@CLASSID INT,
	@JOBID INT,
	@JOBTITLE VARCHAR(50),
	@JOBSTATUS INT = 0,
	@JOBDESCRIPTION VARCHAR(250)
AS
	SET NOCOUNT ON;
	INSERT INTO JOB
	VALUES (@CLASSID, @JOBID, @JOBTITLE, @JOBSTATUS, @JOBDESCRIPTION);
GO

/*
classesAdd
add a class
Dependencies: 
Parameters:
CLASSID INT: OF CLASS
DEPARTMENT (VARCHAR 1): C FOR COMPUTER SCIENCE
CLASSDESCRIPTION (VARCHAR): DESCRIPTION OF CLASS
CLASSNAME (VARCHAR): NAME OF CLASS
*/
CREATE PROCEDURE classesAdd
	@CLASSID INT,
	@DEPARTMENT VARCHAR(1),
	@CLASSDESCRIPTION VARCHAR(280),
	@CLASSNAME VARCHAR(20)
AS
	SET NOCOUNT ON;
	INSERT INTO CLASSES
	VALUES (@CLASSID, @DEPARTMENT,  @CLASSDESCRIPTION, @CLASSNAME);
GO

/*
jobrequirementsAdd
adds a class required for a job applicant
Dependencies: Class must have already been added
Parameters: 
JOBID: ID OF JOB 
CLASSID: ID OF REQUIRED CLASS
GRAD: MINIMUM GRADE REQUIRED IN CLASS
*/

CREATE PROCEDURE jobrequirementsAdd
	@JOBID INT,
	@CLASSID INT,
	@GRADE FLOAT
AS
	INSERT INTO JOB_REQUIREMENTS
	VALUES (@JOBID, @CLASSID, @GRADE);
GO


/*classestakenAdd
adds a class to class list taken by one student
Dependencies: student must exist, class must exist
Parameters:
SID INT: STUDENT ID
CLASSID INT: CLASS ID
GRADE FLOAT: GRADE RECEIVED
ATUMKC BIT: 1 IF THE CLASS WAS TAKEN AT UMKC
LOCATIONTAKEN VARCHAR: WHERE THE CLASS WAS TAKEN
TERM DATE: WHEN THE CLASS WAS TAKEN
*/

CREATE PROCEDURE classestakenAdd
	@SID INT,
	@CLASSID INT,
	@GRADE FLOAT,
	@ATUMKC BIT = 1,
	@LOCATIONTAKEN VARCHAR(50) = "UMKC",
	@TERM DATE
AS
	SET NOCOUNT ON
	INSERT INTO CLASSES_TAKEN
	VALUES(	@SID, @CLASSID, @GRADE, @ATUMKC, @LOCATIONTAKEN, @TERM);
GO



CREATE PROCEDURE termAdd
	@CLASSID INT,
	@TERM DATE,
	@SECTION INT
AS
	SET NOCOUNT ON
	INSERT INTO CLASS_TERMS
	VALUES(@CLASSID, @TERM, @SECTION);
GO



ALTER TABLE APPLICATIONS
ADD JOBSTATUS VARCHAR(20) NOT NULL;
GO

/*
Apply:
Inserts an application into a database for a student
Dependencies: Trigger to prevent inserts if the student doesn’t match the requiremtnes
Parameters:
SID: ID (INT) of student applying
JOB: ID (INT) of job being applied to
*/

CREATE PROCEDURE apply
	@SID INT,
	@JOB INT
AS
	SET NOCOUNT ON
	INSERT INTO APPLICATIONS
	VALUES(@SID, @JOB,'PENDING')
GO


--THIS IS THE TRANSACT TO AUTOMATICALLY TURN ALL APPLICATIONS THAT 
-- HAVENT MADE THE CUT INTO REJECTS
-- BUT WE MAY WANT TO GO A DIFFERENT ROUTE
/*
CREATE TRIGGER reducePositionsAvailable
ON APPLICATIONS AFTER UPDATE
AS
DECLARE @jid int
DECLARE @sid int
DECLARE @status VARCHAR(20)
DECLARE @num int
SELECT 
	@status = inserted.JOBSTATUS,
	@jid = inserted.JOBID,
	@sid = inserted.STUDENTID
    FROM	
      inserted
    INNER JOIN
      deleted
        ON inserted.JOBID = deleted.JOBID AND inserted.JOBID = deleted.STUDENTID;
IF(@status = 'ACCEPTED')
	BEGIN
		
		UPDATE JOB
		SET @num =  POSITIONS_AVAILABLE -= 1
		WHERE JOB.JOB_ID = (SELECT inserted.JOBID FROM inserted
		INNER JOIN deleted
        ON inserted.JOBID = deleted.JOBID AND inserted.JOBID = deleted.STUDENTID)
	END
IF(@num = 0)
		DISABLE TRIGGER reducePositionsAvailable ON ALL SERVER;
		BEGIN
		UPDATE APPLICATIONS
		SET JOBSTATUS = 'REJECTED'
		WHERE JOBSTATUS = 'PENDING' AND JOBID = @jid AND STUDENTID = @sid;
		END;
		ENABLE TRIGGER reducePositionsAvailable ON ALL SERVER;
GO
*/


/*
setAllStuendtsToZero:
Set’s application status to reject for all applications to a specific job that haven’t been set to accepted
Dependencies: 
Parameters:
JOBID: (INT) The ID of the job for which the applicants will be rejected
*/
CREATE PROCEDURE setAllStudentsToZero
	@JOBID INT
AS
	SET NOCOUNT ON
	UPDATE APPLICATIONS
	SET JOBSTATUS = 'REJECTED'
	WHERE JOBSTATUS = 'PENDING' AND JOBID = @JOBID;
GO

/*
rejectOneStudent:
Sets a single application status to rejected based on the student and job
Dependencies:
Parameters:
JOBID INT: ID of job the student has applied to
STUDENT INT: the ID of the student being rejected
*/
CREATE PROCEDURE rejectOneStudent
	@JOBID INT,
	@STUDENT INT
AS
	SET NOCOUNT ON
	UPDATE APPLICATIONS
	SET JOBSTATUS = 'REJECTED'
	WHERE JOBID = @JOBID
GO

/*
acceptStudent
Sets application status to accepted for one student for one job
Dependencies:
Parameters:
STUDENT INT: ID of student being accepted
JOB INT: ID of the job student is accepted for
*/

CREATE PROCEDURE acceptStudent
	@JOBID INT,
	@STUDENT INT
AS
BEGIN
	SET NOCOUNT ON;
	IF(1 <= (SELECT POSITIONS_AVAILABLE
	FROM JOB WHERE JOB_ID = @JOBID))
		BEGIN
		UPDATE JOB 
		SET POSITIONS_AVAILABLE -= 1
		WHERE JOB_ID = @JOBID;
		UPDATE APPLICATIONS
		SET JOBSTATUS = 'ACCEPTED'
		WHERE JOBID = @JOBID AND STUDENTID = @STUDENT;
		RETURN 1;
		END;
	ELSE
		BEGIN
		RETURN 0;
		END;
		
END;
GO


/*

getJobListings:
returns all open job listings
Dependencies: 
Parameters:
*/

CREATE PROCEDURE getJobListings
AS
BEGIN
	SELECT JOB_TITLE
	FROM JOB 
	WHERE POSITIONS_AVAILABLE != 0;
END
GO


/*
getApplicants:
returns all applicants to a specific job
Dependencies: 
Parameters:
JOBTITLE VARCHAR: name of job being searched for
*/

CREATE PROCEDURE getApplicants
	@JOBTITLE VARCHAR(30)
AS
BEGIN
	SELECT STUDENT.FIRST_NAME, STUDENT.LAST_NAME, JOB_REQUIREMENTS.GRADE
	FROM STUDENT
	INNER JOIN APPLICATIONS
	ON APPLICATIONS.STUDENTID = STUDENT.STUDENTID
	INNER JOIN JOB
	ON APPLICATIONS.JOBID = JOB.JOB_ID
	INNER JOIN JOB_REQUIREMENTS
	ON JOB_REQUIREMENTS.JOBID = JOB.JOB_ID
	WHERE JOB_TITLE = @JOBTITLE;
END
GO

/*
getjobsbyclass:
returns all available jobs associated with a specific class
Dependencies: 
Parameters:
CLASSTITLE VARCHAR: name of class being searched for
*/

CREATE PROCEDURE getjobsbyclass
	@CLASSTITLE VARCHAR(30)
AS
BEGIN
	SELECT JOB.JOB_TITLE, JOB.JOB_DESCRIPTION
	FROM JOB
	INNER JOIN CLASSES
	ON JOB.CLASSID = CLASSES.CLASSID
	WHERE JOB.POSITIONS_AVAILABLE > 0 AND CLASS_NAME = @CLASSTITLE;
END
GO

/*
getRequirementsForJob:
returns a list of all classes and grade in class required to apply for job
Dependencies
Parameters:
JOBTITLE VARCHAR: name of job being searched
*/

CREATE PROCEDURE getRequirementsForJob
	@JOBTITLE VARCHAR(30)
AS
BEGIN
	SELECT CLASSES.CLASS_NAME, JOB_REQUIREMENTS.GRADE
	FROM JOB_REQUIREMENTS
	INNER JOIN CLASSES
	ON CLASSES.CLASSID = JOB_REQUIREMENTS.JOBID
	INNER JOIN JOB
	ON JOB.JOB_ID = JOB_REQUIREMENTS.JOBID
	WHERE JOB.JOB_TITLE = @JOBTITLE;
END
GO


/*
getRequirementsNotMet:
returns a list of classes and grade required in class not met to apply for a job posting
Dependencies: Trigger to prevent inserts if the student doesn’t match the requiremtnes
Parameters:
JOBID INT: the ID of the job being searched
STUDENTID INT: the ID of the student being searched
*/

CREATE PROCEDURE getRequirementsNotMet
	@JOBID INT,
	@STUDENTID INT
AS
BEGIN
	SELECT JOB_REQUIREMENTS.CLASSID, CLASSES_TAKEN.GRADE
	FROM JOB_REQUIREMENTS
	LEFT JOIN CLASSES_TAKEN 
	ON CLASSES_TAKEN.CLASSID = JOB_REQUIREMENTS.CLASSID
	WHERE JOB_REQUIREMENTS.JOBID = @JOBID AND (CLASSES_TAKEN.GRADE IS NULL
	OR (CLASSES_TAKEN.GRADE IS NOT NULL AND (CLASSES_TAKEN.GRADE < JOB_REQUIREMENTS.GRADE)))

END
GO



CREATE TRIGGER noApplyUnlessAvailable
ON APPLICATIONS AFTER INSERT 
AS
DECLARE @JID INT = (SELECT TOP 1 JOBID FROM inserted);
IF(0 = (SELECT JOB.POSITIONS_AVAILABLE
	FROM JOB
	WHERE JOB.JOB_ID = @JID))
BEGIN
	RAISERROR('No Jobs Available',1,1);
	ROLLBACK
END
GO



/*
filterJobRequirements:
returns classes and grade in classes needed to apply to a job
Dependencies: 
Parameters:
JOBID INT: ID of the job being applied for
*/

CREATE PROCEDURE filterApplicants
	@JOBID INT,
	@GPA FLOAT,
	@GRADE_LEVEL VARCHAR,
	@ORDER_SEMESTERS BIT,
	@ORDER_GPA BIT,
	@ORDER_TOOK_CLASS BIT
AS
	SELECT * FROM 
	(SELECT STUDENT.FIRST_NAME, STUDENT.LAST_NAME, STUDENT.GPA,
		STUDENT.SEMESTERS_COMPLETED, STUDENT.GRADE_LEVEL,

		CASE
			WHEN
				CLASSES_TAKEN.CLASSID IS NULL
			THEN 'NO'
			ELSE 'YES'
		END
		AS TAKEN1
	FROM JOB
	JOIN APPLICATIONS
	ON JOB.JOB_ID = APPLICATIONS.JOBID
	JOIN STUDENT
	ON STUDENT.STUDENTID = APPLICATIONS.STUDENTID
	LEFT JOIN CLASSES_TAKEN
	ON APPLICATIONS.STUDENTID = CLASSES_TAKEN.STUDENTID AND JOB.CLASSID = CLASSES_TAKEN.CLASSID
	WHERE JOB.JOB_ID = @JOBID) AS K
	ORDER BY
		CASE 
		WHEN @ORDER_GPA = 1 THEN GPA
		WHEN @ORDER_SEMESTERS = 1 THEN SEMESTERS_COMPLETED
		WHEN @ORDER_TOOK_CLASS = 1 THEN TAKEN1
		END DESC;
GO

-- JANKY AF BUT IT SHOULD DO THE TRICK\

-- This trigger should prevent anyone from applying for a job unless they have a gta cert

CREATE TRIGGER gtaCertRequired
	ON APPLICATIONS AFTER INSERT
	AS
		IF((SELECT TOP 1 STUDENT.GTA_CERT_LOCATION FROM STUDENT
		INNER join inserted
		ON inserted.STUDENTID = STUDENT.STUDENTID) IS NULL)
		BEGIN
			RAISERROR('Requirements not met',1,1);
			ROLLBACK
		END
GO



/*
filterApplicants
filters applicants to a job by gpa, , grade level, and orders by either gpa, semesters taken, or if the applicant took the class associated with the job
returns the first name, last name, gpa, semesters complete, grade level, and if the student took the class associated with the job
Dependencies:
Parameters: 
JOBID INT: THE ID OF THE JOB BEING SEARCHED
GPA FLOAT: THE MINIMUM GPA BEING FILTERED FOR
GRADE_LEVEL VARCHAR: IF THE STUDENT IS AN U UNDERGRAD OR G GRADUATE OR P PHD
ORDER_SEMESTERS BIT: 1 IF ORDERING BY NUMBER OF SEMESTERS TAKEN
ORDER_GPA BIT: 1 IF ORDERING BY GPA
ORDER_TOOK_CLASS BIT: 1 IF ORDERING BY IF THE STUDENT TOOK THE CLASS ASSOCIATED WITH THE JOB
*/




CREATE PROCEDURE studentAlter
	@SID int,
	@FIRSTN VARCHAR(20),
	@LASTN VARCHAR(20),
	@YEARGRAD INT,
	@EMAIL VARCHAR(50),
	@PHONE BIGINT,
	@GTACERTLOC VARCHAR(50) = NULL,
	@GTATERM DATE = NULL,
	@INTERNATL BIT = 0,
	@GRADELEVEL VARCHAR(10),
	@GPA FLOAT,
	@HOURSCOMPLETED INT,
	@SEMESTERSCOMPLETED INT,
	@CURRENTMAJOR VARCHAR(50),
	@UNDERGRADDEGREETYPE VARCHAR(50)

AS
	SET NOCOUNT ON;
	UPDATE STUDENT
	SET STUDENTID = @SID,FIRST_NAME =  @FIRSTN, LAST_NAME = @LASTN, YEAR_GRAD =  @YEARGRAD, 
	EMAIL = @EMAIL, PHONE = @PHONE, GTA_CERT_LOCATION =  @GTACERTLOC, GTA_TERM =  @GTATERM, INTERNATL =  @INTERNATL, GRADE_LEVEL =  @GRADELEVEL,
	GPA = @GPA, HOURS_COMPLETED  = @HOURSCOMPLETED, SEMESTERS_COMPLETED = @SEMESTERSCOMPLETED, CURRENT_MAJOR_FEILD = @CURRENTMAJOR, UNDERGRAD_DEGREE_TYPE = @UNDERGRADDEGREETYPE
	WHERE STUDENTID = @SID;
GO

CREATE PROCEDURE studentExists
	@SID INT
AS
	SET NOCOUNT ON;
	SELECT COUNT(STUDENTID) AS SCOUNT
	FROM STUDENT
	WHERE STUDENT.STUDENTID = @SID;
GO

